/**
* CreateCatalogStructureIterator Script File
*
*   @input CatalogReducerDefinition: dw.object.CustomObject
*   @output StoreFrontProductIterator : dw.util.Iterator
*   @output StorefrontCatalog : dw.catalog.Catalog
*
*/


importPackage( dw.system );
importPackage( dw.util );
importPackage( dw.catalog );
importPackage( dw.object );

function execute( args : PipelineDictionary ) : Number
{
    //Retrived from Custom Object
    var numberofProducts : Number = args.CatalogReducerDefinition.custom.numberProducts;
    var onlineProducts : Boolean = args.CatalogReducerDefinition.custom.onlineProducts;
    var storefrontCatalog : Catalog = CatalogMgr.getCatalog(args.CatalogReducerDefinition.custom.storefrontCatalog);

    var rootCategory : Category = storefrontCatalog.getRoot();
    var rootSubCategories :  Collection  = rootCategory.getSubCategories();
    var log : Logger = Logger.getLogger("CatalogReducer","");
    var productExportList : ArrayList = new ArrayList();

    //Calls Recursive function to work through Catalog Structure to get products of all categories
    productExportList = getProductsfromSubCategories(rootSubCategories, productExportList, numberofProducts, onlineProducts, log);  
   
    //Assign User defined Products to correct Array for Exporting
    if (args.CatalogReducerDefinition.custom.productIDs != null)
    {
    	var specificProductIDArrayList : ArrayList = args.CatalogReducerDefinition.custom.productIDs.split(",");
    	assignspecificProductstoArrays(specificProductIDArrayList, productExportList, log);
    }
    
    log.error("Found " + productExportList.size() + " Products to export");
   
	args.StorefrontCatalog =  storefrontCatalog;
	args.StoreFrontProductIterator = productExportList.iterator();
	
	return PIPELET_NEXT;
}




// Function will recursively call itself to get through all subcategories of a catalog and grab Products for each category
function getProductsfromSubCategories(rootSubCategories : Collection, productExportList : ArrayList, numberofProducts : Number, onlineProducts : boolean, log : Logger)
{
	   
	for each (var subCategory : Category in  rootSubCategories)
    {
    	if (subCategory.getSubCategories().length > 0)
        {
        	getProductsfromSubCategories(subCategory.getSubCategories(), productExportList, numberofProducts, onlineProducts, log);
        }
        else
        {
        	if(onlineProducts == true)
        	{
            	var products: Iterator = subCategory.getOnlineProducts().iterator();
            }
            else
            {
            	var products: Iterator = subCategory.getProducts().iterator();
            }
                
         	var count : Number = 0;
                
            while(products.hasNext() && numberofProducts > count)
            {
            	var product : Product = products.next();
           		if(product.isMaster() == true || product.isProductSet() == true || product.isBundle() == true)
            	{   
            		//Called to get all products that make up a complexs type
            		getAllProductsofComplexType(product, productExportList, onlineProducts, log);
            	}
            		
            	if(productExportList.contains(product) != true)
            	{
            		quotaProtection(productExportList, product);
            	}
           	
            	count++;                
            }
       }
	}
return productExportList;
}

//Function takes the user inputted ProductIDS and adds the product object to the array if it is not already added.
function assignspecificProductstoArrays(specificProductIDArrayList : ArrayList, productExportList : ArrayList, log : Logger)
{
    for each(var productID : String in specificProductIDArrayList)
    {
        var product : Product = ProductMgr.getProduct(productID);

        if(product.isMaster() == true || product.isProductSet() == true || product.isBundle() == true)
        {   
        	//Handle Master's Variations
            getAllProductsofComplexType(product, productExportList, false, log);
        }
              
        if(productExportList.contains(product) != true)
        {
           quotaProtection(productExportList, product);
        }    
    }
    
}

//This function gets all the products for complex Product Types(Masters,ProductSets,Bundles) and adds them to the correct export Array
function getAllProductsofComplexType(product : Product, productExportList : ArrayList, onlineProducts : Boolean, log : Logger)
{
	var productCollection : Collection = productTypeCollection(product);
	var count : Number = 0;
	
	for each( var supportingProduct : Product in productCollection)
	{
		if(supportingProduct.isMaster() == true || supportingProduct.isProductSet() == true || supportingProduct.isBundle() == true)
        {   
        		//Handle Master's Variations
            	getAllProductsofComplexType(supportingProduct, productExportList, onlineProducts, log);
        }
        else
        {	
			if(onlineProducts == true)
			{
				if(supportingProduct.isOnline() == true && productExportList.contains(supportingProduct) != true)
				{
					  quotaProtection(productExportList, supportingProduct);
           	 	}		
			}
			else
			{
				if(productExportList.contains(supportingProduct) != true)
				{
					 quotaProtection(productExportList, supportingProduct);
            	}			
			}
		}
		
		count++;
		//This limits variations of a master to 25 variations
		if(product.isMaster() == true && count == 25)
		{
			break;
		}	
	}
	
}

// Get the collection of Products for Complex Product Types
function productTypeCollection(product : Product) : Collection
{
	 if(product.isMaster() == true)
	 {
	 	var  productCollection : Collection = product.getVariants();
	 } 
	 else if (product.isProductSet() == true)
	 {
	 	var  productCollection : Collection = product.getProductSetProducts();
	 }
	 else if(product.isBundle() == true)
	 {
	 	
	 	var  productCollection : Collection = product.getBundledProducts();
	 }
	 
return productCollection;
}

// Function ensures 20000 collection size quota limit is not violated, will stop at 20k regardless
function quotaProtection(productExportList : ArrayList, product : Product, log : Logger)
{
	if(productExportList.size() == 20000)
	{
		log.error("20000 quota limit reached for api.dw.util.collectionSize. Stopping product collection");
		return PIPELET_NEXT;
	}
	else
	{
		productExportList.push(product);
	} 
}